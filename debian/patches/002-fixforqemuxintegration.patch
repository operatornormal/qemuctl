Description: integration of qemu window did not work
Author: Tobias Frost <tobi@coldtobi.de>
Forwared: https://sourceforge.net/p/qemuctl/bugs/6/
Last-Update: <2013-09-07>
---
This patch header follows DEP-3: http://dep.debian.net/deps/dep3/
--- a/qemuctl.cpp
+++ b/qemuctl.cpp
@@ -2,6 +2,66 @@
 
 #include <unistd.h>
 
+#include <X11/Xlib.h>
+#include <X11/Xatom.h>
+#include <list>
+
+using namespace std;
+
+class WindowsMatchingPid
+{
+public:
+    WindowsMatchingPid(Display *display, Window wRoot, unsigned long pid)
+    {
+        _display = display;
+        _pid = pid;
+        _atomPID = XInternAtom(display, "_NET_WM_PID", True);
+        if(_atomPID != None) search(wRoot);
+    }
+
+    const list<Window> &result() const { return _result; }
+
+private:
+    unsigned long  _pid;
+    Atom           _atomPID;
+    Display       *_display;
+    list<Window>   _result;
+
+    void search(Window w)
+    {
+    // Get the PID for the current Window.
+        Atom           type;
+        int            format;
+        unsigned long  nItems;
+        unsigned long  bytesAfter;
+        unsigned char *propPID = 0;
+        if(Success == XGetWindowProperty(_display, w, _atomPID, 0, 1, False, XA_CARDINAL,
+                                         &type, &format, &nItems, &bytesAfter, &propPID))
+        {
+            if(propPID != 0)
+            {
+            // If the PID matches, add this window to the result set.
+                if(_pid == *((unsigned long *)propPID))
+                    _result.push_back(w);
+
+                XFree(propPID);
+            }
+        }
+
+    // Recurse into child windows.
+        Window    wRoot;
+        Window    wParent;
+        Window   *wChild;
+        unsigned  int nChildren;
+        if(XQueryTree(_display, w, &wRoot, &wParent, &wChild, &nChildren))
+        {
+            for(unsigned int i = 0; i < nChildren; i++)
+                search(wChild[i]);
+        }
+    }
+};
+
+
 qemuctl::qemuctl( QStringList * argv, QWidget *parent)
     : QMainWindow(parent)
 {
@@ -788,6 +848,7 @@
         exit(1);
     }
 	list_windows(disp);
+    XCloseDisplay(disp);
 }
 
 int qemuctl::list_windows (Display *disp) {/*{{{*/
@@ -796,6 +857,27 @@
     unsigned int i;
     int max_client_machine_len = 0;
 
+    unsigned long pid = qemuProcess->pid();
+    Window rootw = XDefaultRootWindow(disp);
+    WindowsMatchingPid match(disp, rootw, pid);
+        const list<Window> &result = match.result();
+
+    list<Window>::const_iterator it;
+    for(list<Window>::const_iterator it = result.begin(); it != result.end(); it++)
+    {
+        QString qtitle;
+        qtitle = get_window_title(disp, *it);
+        qDebug("Window %s", get_window_title(disp, *it));
+        if( qtitle.indexOf( QString().sprintf( "QEMUCTL %lld", QApplication::applicationPid() ) ) >= 0 )
+        {
+            winid = *it;
+            return EXIT_SUCCESS;
+        }
+    }
+    return EXIT_FAILURE;
+
+
+#if 0
     if ((client_list = get_client_list(disp, &client_list_size)) == NULL) {
         return EXIT_FAILURE;
     }
@@ -876,6 +958,7 @@
     ////free(client_list);
 
     return EXIT_SUCCESS;
+#endif
 }/*}}}*/
 
 char * qemuctl::get_window_title (Display *disp, Window win) {/*{{{*/
